(function() {
  var Promise, Routes, _, errors, formatResponseBody, os, pkg, request, rp, system;

  _ = require("lodash");

  os = require("os");

  request = require("request-promise");

  errors = require("request-promise/errors");

  Promise = require("bluebird");

  pkg = require("@packages/root");

  Routes = require("./util/routes");

  system = require("./util/system");

  rp = request.defaults(function(params, callback) {
    var headers, method;
    if (params == null) {
      params = {};
    }
    headers = params.headers != null ? params.headers : params.headers = {};
    _.defaults(headers, {
      "x-platform": os.platform(),
      "x-cypress-version": pkg.version
    });
    method = params.method.toLowerCase();
    return request[method](params, callback);
  });

  formatResponseBody = function(err) {
    var body;
    if (_.isObject(err.error)) {
      body = JSON.stringify(err.error, null, 2);
      err.message = [err.statusCode, body].join("\n\n");
    }
    throw err;
  };

  module.exports = {
    ping: function() {
      return rp.get(Routes.ping());
    },
    getOrgs: function(authToken) {
      return rp.get({
        url: Routes.orgs(),
        json: true,
        auth: {
          bearer: authToken
        }
      });
    },
    getProjects: function(authToken) {
      return rp.get({
        url: Routes.projects(),
        json: true,
        auth: {
          bearer: authToken
        }
      });
    },
    getProject: function(projectId, authToken) {
      return rp.get({
        url: Routes.project(projectId),
        json: true,
        auth: {
          bearer: authToken
        },
        headers: {
          "x-route-version": "2"
        }
      });
    },
    getProjectRuns: function(projectId, authToken, options) {
      var ref;
      if (options == null) {
        options = {};
      }
      if (options.page == null) {
        options.page = 1;
      }
      return rp.get({
        url: Routes.projectRuns(projectId),
        json: true,
        timeout: (ref = options.timeout) != null ? ref : 10000,
        auth: {
          bearer: authToken
        }
      })["catch"](errors.StatusCodeError, formatResponseBody);
    },
    createRun: function(options) {
      var body, ref;
      if (options == null) {
        options = {};
      }
      body = _.pick(options, ["projectId", "recordKey", "commitSha", "commitBranch", "commitAuthorName", "commitAuthorEmail", "commitMessage", "remoteOrigin", "ciParams", "ciProvider", "ciBuildNumber", "groupId"]);
      return rp.post({
        url: Routes.runs(),
        json: true,
        timeout: (ref = options.timeout) != null ? ref : 10000,
        headers: {
          "x-route-version": "2"
        },
        body: body
      }).promise().get("buildId")["catch"](errors.StatusCodeError, formatResponseBody);
    },
    createInstance: function(options) {
      if (options == null) {
        options = {};
      }
      return system.info().then(function(systemInfo) {
        var ref;
        return rp.post({
          url: Routes.instances(options.buildId),
          json: true,
          timeout: (ref = options.timeout) != null ? ref : 10000,
          headers: {
            "x-route-version": "3"
          },
          body: _.extend({
            spec: options.spec,
            browserName: "Electron"
          }, systemInfo)
        }).promise().get("instanceId")["catch"](errors.StatusCodeError, formatResponseBody);
      });
    },
    updateInstanceStdout: function(options) {
      var ref;
      if (options == null) {
        options = {};
      }
      return rp.put({
        url: Routes.instanceStdout(options.instanceId),
        json: true,
        timeout: (ref = options.timeout) != null ? ref : 10000,
        body: {
          stdout: options.stdout
        }
      })["catch"](errors.StatusCodeError, formatResponseBody);
    },
    updateInstance: function(options) {
      var ref;
      if (options == null) {
        options = {};
      }
      return rp.put({
        url: Routes.instance(options.instanceId),
        json: true,
        timeout: (ref = options.timeout) != null ? ref : 10000,
        body: _.pick(options, ["tests", "duration", "passes", "failures", "pending", "error", "video", "screenshots", "failingTests", "ciProvider", "cypressConfig", "stdout"])
      })["catch"](errors.StatusCodeError, formatResponseBody);
    },
    createRaygunException: function(body, authToken, timeout) {
      if (timeout == null) {
        timeout = 3000;
      }
      return rp.post({
        url: Routes.exceptions(),
        json: true,
        body: body,
        auth: {
          bearer: authToken
        }
      }).promise().timeout(timeout);
    },
    createSignin: function(code) {
      return rp.post({
        url: Routes.signin({
          code: code
        }),
        json: true,
        headers: {
          "x-route-version": "3"
        }
      })["catch"](errors.StatusCodeError, function(err) {
        err.message = err.error;
        throw err;
      });
    },
    createSignout: function(authToken) {
      return rp.post({
        url: Routes.signout(),
        json: true,
        auth: {
          bearer: authToken
        }
      })["catch"]({
        statusCode: 401
      }, function() {});
    },
    createProject: function(projectDetails, remoteOrigin, authToken) {
      return rp.post({
        url: Routes.projects(),
        json: true,
        auth: {
          bearer: authToken
        },
        headers: {
          "x-route-version": "2"
        },
        body: {
          name: projectDetails.projectName,
          orgId: projectDetails.orgId,
          "public": projectDetails["public"],
          remoteOrigin: remoteOrigin
        }
      })["catch"](errors.StatusCodeError, formatResponseBody);
    },
    getProjectRecordKeys: function(projectId, authToken) {
      return rp.get({
        url: Routes.projectRecordKeys(projectId),
        json: true,
        auth: {
          bearer: authToken
        }
      });
    },
    requestAccess: function(projectId, authToken) {
      return rp.post({
        url: Routes.membershipRequests(projectId),
        json: true,
        auth: {
          bearer: authToken
        }
      })["catch"](errors.StatusCodeError, formatResponseBody);
    },
    getLoginUrl: function() {
      return rp.get({
        url: Routes.auth(),
        json: true
      }).promise().get("url");
    },
    _projectToken: function(method, projectId, authToken) {
      return rp({
        method: method,
        url: Routes.projectToken(projectId),
        json: true,
        auth: {
          bearer: authToken
        },
        headers: {
          "x-route-version": "2"
        }
      }).promise().get("apiToken");
    },
    getProjectToken: function(projectId, authToken) {
      return this._projectToken("get", projectId, authToken);
    },
    updateProjectToken: function(projectId, authToken) {
      return this._projectToken("put", projectId, authToken);
    }
  };

}).call(this);
